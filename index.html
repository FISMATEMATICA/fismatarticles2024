<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>Publications 2024</title>

  <style>
    body {
      font-family: "Segoe UI", Arial, sans-serif;
      margin: 0;
      background-color: #f7f9fc;
      color: #333;
    }

    header {
      background-color: #004d4d;
      padding: 2em;
      text-align: center;
    }

    header h1 {
      color: #ffffff;
      font-size: 2.5em;
      margin: 0;
    }

    #results {
      max-width: 900px;
      margin: 2em auto;
      padding: 0 1em;
    }

    .paper {
      margin-bottom: 1.5em;
      padding: 1.2em;
      background: #ffffff;
      border-left: 6px solid #004d4d;
      border-radius: 8px;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05);
      transition: transform 0.2s ease;
    }

    .paper:hover {
      transform: translateY(-2px);
    }

    .title a {
      font-size: 1.2em;
      font-weight: bold;
      color: #004d4d;
      text-decoration: none;
    }

    .title a:hover {
      text-decoration: underline;
    }

    .meta {
      margin-top: 0.5em;
      color: #555;
      font-size: 0.95em;
    }
  </style>
</head>

<body>
  <header>
    <h1>Publications 2024</h1>
  </header>

  <div id="results">Carregando...</div>

  <script>
    const workerURL = "https://spring-glade-d911.fismat.workers.dev/?url=";

    const nomesDestacados = [
      "Gustavo Burdman", "Renata Zukanovich Funchal", "Oscar Eboli", "O. J. P. Eboli",
      "Gustavo F. S. Alves", "Matheus Martines", "Luighi P. S. Leal", "L.P. Santos Leal",
      "L. P. Santos Leal", "L. P. S. Leal", "Peter Reimitz", "Ana Luisa Foguel",
      "Gabriel M. Salla", "Oscar J. P. Éboli", "Lucas Magno D. Ramos",
      "Gustavo S.S. Sakoda", "G.S.S. Sakoda", "Disha Bhatia", "Sujay Shil",
      "Rafiqul Rahaman", "Barbara Amaral", "Eduardo Casali", "Elisa G.M. Ferreira",
      "Frederique Grassi", "J.C.A. Barata", "João C. A. Barata", "Joao C. A. Barata",
      "L.R.W.Abramo", "L. Raul Abramo", "R. Abramo", "Raul Abramo", "Natália V.N. Rodrigues",
      "Marcos Lima", "Matthew Luzum", "Luis Raul Abramo", "João Vitor Dinarte Ferri",
      "Igor Neiva Mesquita", "Álvaro S. de Jesus", "Á.S. de Jesus", "Naim Elias Comar",
      "Alisson Tezzin", "Ian Tashiro", "Kevin Pala", "Pedro Ishida", "Luis F. Santos",
      "Luís F. Santos", "L. R. Abramo", "O. J. P. Éboli", "Bárbara Amaral",
      "R. Zukanovich Funchal", "Pedro Bittar"
    ];

    // Normaliza texto: remove acentos, pontuação básica e deixa lowercase
    function norm(text) {
      if (!text) return "";
      // remove diacríticos
      let s = text.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
      // remove pontuação comum (.,;:()[]{}<>/\"') e caracteres especiais, keep letters and numbers and spaces
      s = s.replace(/[^0-9a-zA-Z\s]/g, " ");
      // collapse spaces
      s = s.replace(/\s+/g, " ").trim().toLowerCase();
      return s;
    }

    // retorna array de tokens (palavras) do nome normalizado
    function tokens(text) {
      const n = norm(text);
      return n ? n.split(" ").filter(Boolean) : [];
    }

    // Verifica se nome destacado corresponde ao nome do autor do arXiv
    // regra: se nomeDestTokens.length > 1 -> todos os tokens devem estar presentes em authorTokens
    //        se nomeDestTokens.length == 1 -> exige match exato (evita coincências por sobrenome comum)
    function authorMatchesHighlighted(authorName) {
      const authorTokens = tokens(authorName);
      for (const highlighted of nomesDestacados) {
        const hTokens = tokens(highlighted);
        if (hTokens.length === 0) continue;

        if (hTokens.length === 1) {
          // single-token highlighted: require exact token match among author tokens
          if (authorTokens.includes(hTokens[0])) return true;
        } else {
          // multi-token highlighted: require ALL tokens to be present in authorTokens
          let allPresent = true;
          for (const t of hTokens) {
            if (!authorTokens.includes(t)) { allPresent = false; break; }
          }
          if (allPresent) return true;
        }
      }
      return false;
    }

    // mesma função, mas para usar quando já temos lista de authors tokens:
    function anyHighlightedInAuthors(authorsArray) {
      // authorsArray: ["Name One", "Name Two", ...]
      for (const a of authorsArray) {
        if (authorMatchesHighlighted(a)) return true;
      }
      return false;
    }

    async function carregarResultados() {
      const autoresQuery = nomesDestacados
        .map(nome => `au:"${nome.replace(/"/g, "").replace(/\s+/g, "+")}"`)
        .join("+OR+");

      const arxivURL =
        `https://export.arxiv.org/api/query?search_query=${autoresQuery}&sortBy=submittedDate&sortOrder=descending&max_results=300`;

      try {
        const response = await fetch(workerURL + encodeURIComponent(arxivURL));
        const xmlText = await response.text();
        const parser = new DOMParser();
        const xml = parser.parseFromString(xmlText, "application/xml");

        // detect parser error
        if (xml.querySelector("parsererror")) {
          throw new Error("Erro ao parsear XML retornado pelo Worker.");
        }

        const entries = Array.from(xml.querySelectorAll("entry"));
        const vistos = new Set();
        let papers = [];

        entries.forEach(entry => {
          const id = entry.querySelector("id")?.textContent;
          if (!id || vistos.has(id)) return;
          vistos.add(id);

          const published = entry.querySelector("published")?.textContent?.slice(0,10) || "";
          const updated = entry.querySelector("updated")?.textContent?.slice(0,10) || "";

          const anoValido =
            (published && published.startsWith("2024")) ||
            (updated && updated.startsWith("2024"));

          if (!anoValido) return;

          const finalDate = updated || published;

          const title = entry.querySelector("title")?.textContent.trim() || "Sem título";
          const link = id;

          const authors = Array.from(entry.querySelectorAll("author > name"))
            .map(a => a.textContent.trim());

          // NEW: usar a função robusta de match
          if (!anyHighlightedInAuthors(authors)) return; // pular se nenhum autor destacado

          // reorganiza autores: destacados primeiro (preservando ordem relativa)
          const destacados = authors.filter(a => authorMatchesHighlighted(a));
          const outros = authors.filter(a => !authorMatchesHighlighted(a));
          const ordenados = [...destacados, ...outros];

          const exibidos = ordenados.length > 8
            ? [...ordenados.slice(0, 8), "et al."]
            : ordenados;

          const authorsHTML = exibidos
            .map(a => authorMatchesHighlighted(a) ? `<strong>${a}</strong>` : a)
            .join(", ");

          const journalRef = entry.querySelector("arxiv\\:journal_ref, journal_ref");
          const journal = journalRef ? journalRef.textContent.trim() : "";

          papers.push({
            published: finalDate,
            html: `
              <div class="paper">
                <div class="title"><a href="${link}" target="_blank" rel="noopener noreferrer">${escapeHtml(title)}</a></div>
                <div class="meta">Autores: ${escapeHtml(authorsHTML)}</div>
                <div class="meta">Publicado em: ${escapeHtml(finalDate)}</div>
                ${journal ? `<div class="meta">${escapeHtml(journal)}</div>` : ""}
              </div>
            `
          });
        });

        // ordenar do mais recente para o mais antigo
        papers.sort((a,b) => b.published.localeCompare(a.published));

        document.getElementById("results").innerHTML =
          papers.map(p => p.html).join("") || "Nenhum artigo de 2024 encontrado.";

      } catch (error) {
        document.getElementById("results").innerHTML =
          "Erro ao carregar os dados: " + error.message;
      }
    }

    // helper para escapar HTML em títulos/journals/autor
    function escapeHtml(text) {
      if (!text) return "";
      return text.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;")
                 .replace(/"/g,"&quot;").replace(/'/g,"&#039;");
    }

    carregarResultados();
  </script>
</body>
</html>
